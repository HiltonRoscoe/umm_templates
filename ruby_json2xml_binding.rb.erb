<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet  xmlns="http://www.w3.org/2005/xpath-functions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cdf="NIST_V2_election_results_reporting.xsd" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:math="http://www.w3.org/2005/xpath-functions/math" xmlns:array="http://www.w3.org/2005/xpath-functions/array" xmlns:map="http://www.w3.org/2005/xpath-functions/map" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:err="http://www.w3.org/2005/xqt-errors" exclude-result-prefixes="array cdf fn map math xhtml err xs xsi" version="3.0">
	<xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes"/>
  <xsl:import-schema namespace="NIST_V2_election_results_reporting.xsd" schema-location="NIST_V2_election_results_reporting.xsd" />
	<xsl:template match="root" priority="1">
		<xsl:variable name="xml">
      <ElectionResults>
			  <xsl:apply-templates select="json-to-xml(.)"/>
      </ElectionResults>
		</xsl:variable>
		<xsl:copy-of select="$xml"/>
	</xsl:template>
  <% require 'active_support/inflector'
%>
<% xml_schema_stereotype = @all_packages.collect{|p| p.applied_stereotypes}.flatten.find{|s| s.name == 'XML Schema'}
  @outer_module = @locals[:outer_module] || 'OuterModule'
  object_id_attr = xml_schema_stereotype.applied_tags.find{|t| t.name == 'id_attribute_name'}.value
  id_suffix = xml_schema_stereotype.applied_tags.find{|t| t.name == 'id_suffix_for_references'}.value rescue 'Id'
  plural_id_suffix = xml_schema_stereotype.applied_tags.find{|t| t.name == 'id_suffix_for_plural_references'}.value rescue 'Ids'
  version = @locals[:version]
  version ||= 'v' + @all_packages.collect{|p| p.applied_stereotypes}.flatten.find{|s| s.name == 'XML Schema'}.applied_tags.find{|t| t.name == 'major_version'}.value rescue nil
  raise "You must specify a version for the domain model" unless version

  def get_property_name(property, singular_id_suffix, plural_id_suffix, pluralize_roles = false, underscore = false)
  	name = property.name
    name ||= property.type.name
    name = name.underscore if underscore
    if property.association? && !(property.attribute? || property.composite?)
      id_suffix = property.multiple? ? plural_id_suffix : singular_id_suffix
      name = name + id_suffix 
    else
      name = name.pluralize if property.multiple? && pluralize_roles 
    end
    name 
  end

  def get_default_value(property)
    if property.multiple?
      ", :default => []"
    end
  end

  def get_property_type(property)
    if !(property.type.primitive? || property.type.enumeration? || (property.association? && !(property.attribute?) && !(property.composite?))) # This may not cover all necessary cases
      "map"
    elsif property.type.primitive? && [UmlMetamodel::PRIMITIVES[:integer],UmlMetamodel::PRIMITIVES[:float], UmlMetamodel::PRIMITIVES[:double]].include?(property.type.base_primitive)
      "number"
    elsif property.type.primitive? && [UmlMetamodel::PRIMITIVES[:boolean]].include?(property.type.base_primitive)
      "boolean"
    else
      "string"
    end
  end
%>

<% @all_packages.each do |package| %>
<% fully_qualified_package_name = @outer_module + '.' + package.qualified_name%>
<% package.classes.sort_by{|c|c.name}.each do |klass| %>
<%# the not ensures we don't match any parent types, we will call them explicitly %>
<%# abstracts should have no match!%>
  <xsl:template name="cdf:<%= klass.name %>" match="*[string/@key = '@type' and string = 'ElectionResults.<%= klass.name %>']"<%if klass.children.any?%> priority="-1" <%end%> xpath-default-namespace="http://www.w3.org/2005/xpath-functions">
    <xsl:param name="set_type" select="false()" />
<% if klass.parents.empty? && klass.properties.any?{|property| property.association? && property.opposite.is_navigable && !property.opposite.composite? }%>
<% end %>
  <% if klass.parents.empty? && klass.properties.any?{|property| property.association? && property.opposite.is_navigable && !property.opposite.composite? } %>
    <string key="@id"><xsl:value-of select="@ObjectId" /></string>
  <% end %>
<% klass.properties.sort_by{|p|(p.name || p.type.name).underscore}.each do |property| %>
<% next unless property.is_navigable %>
<% property_name = get_property_name(property, id_suffix, plural_id_suffix) %>
<% klass_has_simple_content = klass.properties.any?{|p| p.applied_stereotypes.any?{|s| s.name == 'simpleContent'}} %>
<% is_xml_attribute = (klass_has_simple_content &&  !property.applied_stereotypes.any?{|s| s.name == 'simpleContent' }) || property.applied_stereotypes.any?{|s| s.name == 'xmlAttribute'} %>
<%# determine if we need to output the property %>
<% if is_xml_attribute %>
  <xsl:if test="boolean(@<%= property_name %>)">
<% elsif property.applied_stereotypes.any?{|s| s.name == 'simpleContent' } %>
  <string key="Data"><xsl:value-of select="." /></string>
<% next %>
<% else %>
  <xsl:if test="boolean(*[@key = '<%= property_name %>'])">
<% end %>
    <%# if it is an array, then we need to apply special logic %>
    <% calculated_data_type = property.multiple? ? 'array' : get_property_type(property) %>
    <% is_idrefs = !property.composite? && property.association? %>
        <% if property.multiple? %>
          <% if is_idrefs %>
          <%# handle the use of IDREFS, which must map to arrays %>
            <!--<xsl:for-each select="tokenize(cdf:<%=property_name%>)">-->
            <xsl:for-each select="*[@key = '<%= property_name %>']/map">
          <% else %>
            <xsl:for-each select="*[@key = '<%= property_name %>']/map">
          <% end %>
            <% if get_property_type(property) == 'map' %>
              <%# use anonynomous map %>
              <<%= property_name %>>
                <xsl:apply-templates select="." />
              </<%= property_name %>>
            <% elsif is_xml_attribute %>
              <<%= get_property_type(property) %>>    
                <xsl:value-of select="." />
              </<%= get_property_type(property) %>>    
            <% else %>
              <<%= property_name %>>    
                <xsl:value-of select="*[@key = '<%= property_name %>']"/>
              </<%= property_name %>>    
            <% end %>                        
          </xsl:for-each>
        <%else%>
        <<%= property_name %>>
          <% if get_property_type(property) == 'map' %>
            <xsl:apply-templates select="cdf:<%= property_name %>" />
          <% elsif is_xml_attribute %>
            <xsl:value-of select="@<%= property_name %>" />
          <% else %>
            <xsl:value-of select="*[@key = '<%= property_name %>']"/>
          <% end %>
        </<%= property_name %>>
        <% end %>
</xsl:if>
<% end %>
  <xsl:if test="not($set_type)">    
  </xsl:if>
  <%# Call parent class' template %>
  <%if klass.parents.any?%>
    <xsl:call-template name="cdf:<%=klass.parents.first.name%>">
      <xsl:with-param name="set_type" select="true()" />
    </xsl:call-template>
  <% end %>
  </xsl:template>
<% end %>
<% end %>
</xsl:stylesheet>